------------------------------------------------------------
introduction

what this book isn't about
  penetration testing
  using frameworks like peachfuzz and autodafe
  replacing any other kind of testing
  statistical reliability-- this used to be what SE people thought
    random testing was for

what it is about
  justifiably increasing (or decreasing!) confidence in software
  finding difficult bugs earlier

should you use random testing? yes if...
  unit tests all pass; if not fix those first!
  you are exporting an API that sits at a trust boundary
  you really care about robustness
do not use if...
  no time/energy to fix defects that don't (yet) concern customers
  no time/energy to invest in creating a random tester
  it's a one-off script (shell, perl, etc.) and you can just look at the output
  it's a one-off script and its input is extremely difficult to randomize,
    for example because it invovles a big directory hierarchy or a collection
    of machines on the interet
  can't find a workable oracle

fuzzing occupies a unique niche, complements all of...
  code inspections
  unit tests
  static analysis
  even formal verification

why is random testing good?
  forces corner cases to be confronted
    can that library call return null??
  makes fewer assumptions
    equivalently, avoids blind spots (Frozen Keyboard p. 28)
  people aren't good at reasoning about corner cases and interactions
    between distant parts of a system
  if you knew where the bug was, you'd write the test case for it
    but you don't!
    hard to write test cases for one's own blind spots--randomization can help find them

how to use random testing
  ideal: develop the test-case generator along with the software
    early on, both are bad-- which is good
    later, both are good-- which is also good!

------------------------------------------------------------
background on testing 

need to keep this short

the question is: what do we need to introduce?
- domains and ranges
- oracles
- sources of input: 
  APIs provided by the SUT
  APIs used by the SUT
  implicit inputs: context switches, etc

how much testing is enough?
  briefly introduce coverage?

see Udacity notes in john_notes.txt

------------------------------------------------------------
building a random tester

this chapter is example-driven
  fuzzing a python red-black tree 
  credit card validation or CRC, to illustrate nasty input validity issues

introduce grammar-based test case generation
  sometimes this is overkill (linked list)
  sometimes it's insufficient (csmith)
  but still, it's a good way to think about test case generation
  observation: 
    grammers are usually used to describe parsers
    test case generators are basically parsers driven in reverse
  other times an FSM / markov chain is the right way to think of a test
    case generator

hard vs soft requirements on input validity
  compiler undefined behavior example, pointers in library
  getting C programs from: random bits, random chars, random tokens

talk about fuzzing in the small ("unit fuzzing") vs. in the large
  can't get good coverage of large systems-- just trying to find bugs
  for small codes, can also increase confidence that it's correct

important: it's very different between fuzzing an internal API
  and fuzzing a trust boundary

when restricting the inputs generated by a random tester, keep
  notes so these can be relaxed later
  e.g. randomized malloc doesn't return NULL

how to choose probabiltiies?
  initially, uniform distribution
  then refine

------------------------------------------------------------
using feedback from coverage

introduce coverage, focus on statement and branch
  explain why branch is nice: it catches the implicit elses

easy to hide from a random tester like this
  if (x==34450372837987) BUG()
  BUT this produces an obvious coverage failure
    so you need to understant what is needed to overcome this failure

this feedback loop includes the tester

quandary: how much coverage is "good"?
  unit testing: goal should be 100% except uncoverable code
    if this is not achievable, maybe the unit being tested is too big
  system testing: this is hard

coverage isn't everything:
  also take a look at test cases, if applicable
  look at system outputs

when refining the tester, be very careful not to lose power

------------------------------------------------------------
test oracles

approach is to ask: What's the code supposed to do?
  then try to write a check for that
see blog posts about oracles, including comments
also:
  DoS-- stops responding to other requests
  strace, to see which files are opened
  library interception-- LD_PRELOAD

challenging to find oracles for:
  GUI programs
  Alex's huge, slow, one-off scientific codes 
  embedded systems (engine control, autopilot, ...)

------------------------------------------------------------
a complete example

go through everything for an ADT

------------------------------------------------------------
reporting bugs

test case reduction 
see Csmith web pages, gcc web pages, etc.
making an argument that a bug should be fixed

------------------------------------------------------------
mutation-based fuzzing

totally random
structure-aware

------------------------------------------------------------
advanced practical issues

test loop automation
  invoking oracles
  setup and cleanup for each test
    super important to not screw this up...
  protecting from resouce over-use
  insulating from fuzzer damage: use a VM or other sandbox

longevity of test session

test case size

------------------------------------------------------------
research issues

search-based testing: feedback from coverage
concolic testing
swarm testing
random testing papers

------------------------------------------------------------
conclusions

------------------------------------------------------------
appendix: recommended testing and debugging books, papers, links
 
http://pages.cs.wisc.edu/~rist/642-fall-2012/toorcon.pdf
http://www.yendor.com/testing/
http://bugsareeasy.wordpress.com/2010/05/19/the-coming-crisis-in-constrained-random-test-generation/
quickcheck

------------------------------------------------------------
